// Copyright 2025 The Aliax Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package cmd

import (
	"aliax/internal/aos"
	bashast "aliax/internal/ast/bash"
	psast "aliax/internal/ast/powershell"
	"aliax/internal/cfg"
	"aliax/internal/shell"
	"aliax/internal/style"
	bashtoken "aliax/internal/token/bash"
	token "aliax/internal/token/powershell"
	"errors"
	"path/filepath"
	"runtime"
	"time"

	"fmt"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/ansurfen/globalenv"
	"github.com/caarlos0/log"
	"github.com/spf13/cobra"
)

// initCmdParameter stores parameters for the "init" command.
type initCmdParameter struct {
	global  bool
	force   bool
	verbose bool

	start time.Time
}

var (
	initParameter initCmdParameter
	initCmd       = &cobra.Command{
		Use:   "init",
		Short: "Initialize the aliax workspace and generate execution scripts",
		Long: `The "init" command scans the aliax configuration file and generates necessary execution scripts.
It creates platform-specific scripts in the "run-scripts" directory for alias commands and extensions.
If the --global (-g) flag is set, it applies configurations globally.`,
		Example: "  aliax init\n  aliax init --global",
		Run: func(cmd *cobra.Command, args []string) {
			if initParameter.verbose {
				initParameter.start = time.Now()
				log.SetLevel(log.DebugLevel)
			}
			var file cfg.Aliax
			err := aos.ReadYAML(config, &file)
			if err != nil {
				log.WithError(err).Fatalf("fail to parse file")
			}
			err = aos.MkdirAll("run-scripts/bash", 0755)
			if err != nil {
				if errors.Is(err, os.ErrExist) {
					log.WithError(err).Warn("making run-scripts directory")
				} else {
					log.WithError(err).Fatal("making run-scripts directory")
				}
			}

			extBins := map[string]string{}

			for name, ext := range file.Extend {
				if len(ext.Bin) == 0 {
					ext.Bin, err = shell.LookPath(name)
					if err != nil {
						log.WithError(err).Fatal("looking path")
					}
				} else {
					if runtime.GOOS == "windows" {
						ext.Bin = envArguments.ReplaceAllStringFunc(ext.Bin, func(s string) string {
							matched := envArguments.FindAllStringSubmatch(s, -1)
							if len(matched) > 0 && len(matched[0]) > 1 {
								return fmt.Sprintf("$env:%s", matched[0][1])
							}
							return s
						})
					} else {
						ext.Bin = envArguments.ReplaceAllStringFunc(ext.Bin, func(s string) string {
							matched := envArguments.FindAllStringSubmatch(s, -1)
							if len(matched) > 0 && len(matched[0]) > 1 {
								return fmt.Sprintf("$%s", matched[0][1])
							}
							return s
						})
					}
				}
				extBins[name] = ext.Bin
				file.Extend[name].Bin = ext.Bin
			}

			parseCommands(file.Extend)

			parseCommands(file.Command)

			if initParameter.global {
				if err = setGlobal(); err != nil {
					log.WithError(err).Fatal("setting for the global")
				} else {
					data, err := getAliaxPath()
					if err != nil && !errors.Is(err, errAliaxPathNotFound) {
						log.WithError(err).Fatal("setting environment")
					}
					for k, v := range extBins {
						data[k] = v
					}
					output, err := setAliaxPath(data)
					if err != nil {
						log.WithField("output", string(output)).WithError(err).Fatal("setting environment")
					}
					log.Info("setting for the global")
				}
			}
			log.Info("thanks for using aliax!")
			if initParameter.verbose {
				duration := time.Since(initParameter.start)
				log.Debugf("executing succeded after %s", style.Bold(duration.String()))
			}
		},
	}
)

func parseCommands(cmds map[string]*cfg.Command) {
	for name, cmd := range cmds {
		filename := fmt.Sprintf("./run-scripts/%s.ps1", name)
		psFile, err := aos.Create(filename)
		if err != nil {
			if errors.Is(err, os.ErrExist) && !initParameter.force {
				log.WithError(err).
					WithField("file", filename).
					WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
						style.Keyword("aliax clean"),
						style.Keyword("-f"))).
					Fatal("file already exist")
			} else {
				log.WithError(err).Fatal("fail to create file")
			}
		}

		psNode := &psast.File{}
		psNode.Stmts = append(psNode.Stmts, &psast.Comment{
			Text: "Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
		})
		psNode.Stmts = append(psNode.Stmts, &psast.AssignStmt{
			Lhs: &psast.RefExpr{X: &psast.Ident{Name: "executable"}},
			Rhs: &psast.BasicExpr{Kind: token.STRING, Value: cmd.Bin},
		})
		if bs, ok := translate2Powershell(name, name, 0, cmd).([]psast.Stmt); ok {
			psNode.Stmts = append(psNode.Stmts, bs...)
		}
		psNode.Stmts = append(psNode.Stmts, &psast.CallStmt{
			CallOp: token.AND,
			Func:   &psast.RefExpr{X: &psast.Ident{Name: "executable"}},
			Recv:   []psast.Expr{&psast.RefExpr{X: &psast.Ident{Name: "args"}}},
		})
		psast.Print(psNode, psFile)
		psFile.Close()

		filename = fmt.Sprintf("./run-scripts/%s.sh", name)

		shFile, err := aos.Create(filename)
		if err != nil {
			if errors.Is(err, os.ErrExist) && !initParameter.force {
				log.WithError(err).
					WithField("file", filename).
					WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
						style.Keyword("aliax clean"),
						style.Keyword("-f"))).
					Fatal("file already exist")
			} else {
				log.WithError(err).Fatal("fail to create file")
			}
		}

		shNode := &bashast.File{}
		shNode.Stmts = append(shNode.Stmts, &bashast.Comment{
			Text: "!/bin/bash",
		}, &bashast.Comment{
			Text: " Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
		}, &bashast.ExprStmt{X: &bashast.Ident{Name: "set -e"}})
		shNode.Stmts = append(shNode.Stmts, &bashast.AssignStmt{
			Lhs: &bashast.Ident{Name: "executable"},
			Rhs: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: cmd.Bin},
		})
		shNode.Stmts = append(shNode.Stmts, &bashast.ExprStmt{X: &bashast.Ident{Name: `args=("$@")`}})
		if bs, ok := translate2Bash(name, name, 0, cmd).([]bashast.Stmt); ok {
			shNode.Stmts = append(shNode.Stmts, bs...)
		}
		shNode.Stmts = append(shNode.Stmts,
			&bashast.CallStmt{
				Func: &bashast.RefExpr{X: &bashast.Ident{Name: "executable"}},
				Recv: []bashast.Expr{&bashast.Ident{Name: `"${args[@]}"`}},
			})
		bashast.Print(shNode, shFile)
		shFile.Close()

		target, err := filepath.Abs(shFile.Name())
		if err != nil {
			log.WithError(err).Fatal("invalid path")
		}
		link := filepath.Join(filepath.Dir(target), "bash", strings.TrimSuffix(filepath.Base(target), ".sh"))

		if ok, _ := aos.Exist(link); ok && initParameter.force {
			log.WithField("link", link).Info("deleting old symbol link")
			err = os.Remove(link)
			if err != nil {
				log.WithError(err).Fatal("fail to delete file")
			}
		}
		if runtime.GOOS == "windows" {
			err = shell.Run("cmd", "/C", "mklink", link, target)
		} else {
			err = shell.Run("ln", "-s", target, link)
		}
		if err != nil {
			log.WithField("suggestion", fmt.Sprintf("If the error is that the file already exists,\nrun %s and try again", style.Keyword("aliax clean"))).Fatalf("creating symbol link for %s", target)
		}
	}
}

func init() {
	aliaxCmd.AddCommand(initCmd)
	initCmd.PersistentFlags().BoolVarP(&initParameter.global, "global", "g", false, "Apply the initialization globally, affecting the entire system instead of the current project")
	initCmd.PersistentFlags().BoolVarP(&initParameter.force, "force", "f", false, "")
	initCmd.PersistentFlags().BoolVarP(&initParameter.verbose, "verbose", "v", false, "")
}

var (
	namedArguments = regexp.MustCompile(`\{\{\s*\.(\w+)\s*\}\}`)
	indexArguments = regexp.MustCompile(`\{\{\s*\$(\d+)\s*\}\}`)
	envArguments   = regexp.MustCompile(`\{\{\s*\$\w+\.(\w+)\s*\}\}`)
)

func setGlobal() error {
	var (
		value string
		err   error
	)
	if runtime.GOOS == "windows" {
		value, err = globalenv.Get("Path")
	} else {
		value, err = globalenv.Get("PATH")
	}
	if err != nil {
		return err
	}
	path, err := os.Getwd()
	if err != nil {
		return err
	}
	path = filepath.Join(path, "run-scripts")
	if !strings.Contains(value, path) {
		var output []byte
		if runtime.GOOS == "windows" {
			output, err = globalenv.Set("Path", fmt.Sprintf("%s;%s", path, value))
		} else {
			output, err = globalenv.Set("PATH", fmt.Sprintf("$PATH:%s", path))
		}
		if err != nil {
			log.WithField("output", string(output)).Error("setting Path")
			return err
		}
	}
	log.WithField("path", path).Warn("the environment variable is already set")
	return nil
}

func translate2Powershell(ident, cmdName string, level int, cmd *cfg.Command) psast.Node {
	subCommand := []psast.Stmt{}
	for name, subcmd := range cmd.Command {
		subNode := translate2Powershell(fmt.Sprintf("%s_%s", ident, name), name, level+1, subcmd)
		if subNode, ok := subNode.([]psast.Stmt); ok {
			subCommand = append(subCommand, subNode...)
		}
	}
	bs := []psast.Stmt{}
	if level > 0 {
		ifStmt := &psast.IfStmt{Body: &psast.BlockStmt{}}
		bs = append(bs, ifStmt)
		ifStmt.Cond = &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.IndexExpr{X: &psast.Ident{Name: "args"}, Key: &psast.BasicExpr{Kind: token.NUMBER, Value: "0"}}}, Op: token.EQ, Y: &psast.BasicExpr{Kind: token.STRING, Value: cmdName}}
		ifStmt.Body.List = append(ifStmt.Body.List, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: "args"}}, Rhs: &psast.RefExpr{X: &psast.IndexExpr{X: &psast.Ident{Name: "args"}, Key: &psast.BinaryExpr{X: &psast.BasicExpr{Kind: token.NUMBER, Value: "1"}, Op: token.DOUBLE_DOT, Y: &psast.RefExpr{X: &psast.SelectorExpr{X: &psast.Ident{Name: "args"}, Sel: &psast.Ident{Name: "Length"}}}}}}})

		ifStmt.Body.List = append(ifStmt.Body.List, psBlockStmtBuild(subCommand, ident, cmd)...)
	} else {
		bs = psBlockStmtBuild(subCommand, ident, cmd)
	}

	return bs
}

func psBlockStmtBuild(subCommand []psast.Stmt, ident string, cmd *cfg.Command) (bs []psast.Stmt) {
	for i, sc := range subCommand {
		if i == 0 {
			if i != len(subCommand)-1 {
				bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: fmt.Sprintf("temp_args_%s", ident)}}, Rhs: &psast.RefExpr{X: &psast.Ident{Name: "args"}}})
			}
			bs = append(bs, sc)
		} else {
			bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: "args"}}, Rhs: &psast.RefExpr{X: &psast.Ident{Name: fmt.Sprintf("temp_args_%s", ident)}}})
			bs = append(bs, sc)
		}
	}

	// init variables
	typeDict := map[string]token.Token{}
	for _, flag := range cmd.Flags {
		flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
		switch flag.Type {
		case "string":
			typeDict[flagIdent] = token.STRING
			bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}}, Rhs: psast.Null})
		case "bool":
			typeDict[flagIdent] = token.BOOL
			bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}}, Rhs: psast.False})
		}
	}
	bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: "non_matched_args"}}, Rhs: &psast.Ident{Name: "@()"}})

	if len(cmd.Flags) > 0 {
		forStmt := &psast.ForStmt{
			Init: &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.ASSIGN, Y: &psast.BasicExpr{Kind: token.NUMBER, Value: "0"}},
			Cond: &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.LT, Y: &psast.RefExpr{X: &psast.SelectorExpr{X: &psast.Ident{Name: "args"}, Sel: &psast.Ident{Name: "Length"}}}},
			Post: &psast.IncDecExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.Inc},
			Body: &psast.BlockStmt{}}
		bs = append(bs, forStmt)

		switchStmt := &psast.SwitchStmt{
			Regex: true,
			Cond:  &psast.RefExpr{X: &psast.IndexExpr{X: &psast.Ident{Name: "args"}, Key: &psast.RefExpr{X: &psast.Ident{Name: "i"}}}},
			Default: &psast.CaseStmt{
				Body: &psast.BlockStmt{
					List: []psast.Stmt{
						&psast.ExprStmt{
							X: &psast.BinaryExpr{
								X:  &psast.RefExpr{X: &psast.Ident{Name: "non_matched_args"}},
								Op: token.ADD_ASSIGN,
								Y:  &psast.Ident{Name: "$args[$i]"},
							},
						},
					},
				},
			},
		}
		forStmt.Body.List = append(forStmt.Body.List, switchStmt)

		for _, flag := range cmd.Flags {
			flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
			alias := []string{}
			if len(flag.Alias) == 0 {
				alias = append(alias, flag.Name)
			} else {
				alias = append(alias, flag.Alias...)
			}
			for i, a := range alias {
				alias[i] = regexp.QuoteMeta(a)
			}
			rule := strings.Join(alias, "|")
			caseStmt := &psast.CaseStmt{
				Cond: &psast.BasicExpr{Kind: token.STRING, Value: rule},
				Body: &psast.BlockStmt{},
			}
			switchStmt.Cases = append(switchStmt.Cases, caseStmt)
			switch flag.Type {
			case "string":
				caseStmt.Body.List = append(caseStmt.Body.List, &psast.AssignStmt{
					Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}},
					Rhs: &psast.IndexExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "args"}}, Key: &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.ADD, Y: &psast.BasicExpr{Kind: token.NUMBER, Value: "1"}}},
				})
				caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
					X: &psast.IncDecExpr{
						X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
						Op: token.Inc,
					},
				})
			case "bool":
				caseStmt.Body.List = append(caseStmt.Body.List, &psast.AssignStmt{
					Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}},
					Rhs: psast.True,
				})
				// caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
				// 	X: &psast.IncDecExpr{
				// 		X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
				// 		Op: token.Inc,
				// 	},
				// })
			}
		}

		type sortedMatchCase struct {
			weight int
			names  []string
			body   string
		}

		match := []sortedMatchCase{}
		var defaultMatchCase *sortedMatchCase
		for _, matchCase := range cmd.Match {
			if len(matchCase.Platform) > 0 && matchCase.Platform != "powershell" {
				continue
			}
			names := []string{}
			matchCase.Run = indexArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := indexArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					i, _ := strconv.Atoi(matched[0][1])
					i--
					return fmt.Sprintf(`"$($args[%d])"`, i)
				}
				return s
			})
			matchCase.Run = namedArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := namedArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					return fmt.Sprintf("$%s_%s", ident, matched[0][1])
				}
				return s
			})
			matchCase.Run = envArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := envArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					return fmt.Sprintf("$env:%s", matched[0][1])
				}
				return s
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					defaultMatchCase = &sortedMatchCase{
						body: matchCase.Run,
					}
					continue
				}
				names = append(names, fmt.Sprintf("%s_%s", ident, pattern))
			case []any:
				for _, v := range pattern {
					if v, ok := v.(string); ok {
						names = append(names, fmt.Sprintf("%s_%s", ident, v))
					}
				}
			}
			if len(names) != 0 {
				match = append(match, sortedMatchCase{weight: len(names), names: names, body: matchCase.Run})
			}
		}

		if len(match) == 0 {
			return bs
		}

		sort.Slice(match, func(i, j int) bool {
			return match[i].weight > match[j].weight
		})

		matchStmt := &psast.IfStmt{Body: &psast.BlockStmt{}}
		bs = append(bs, matchStmt)
		for i, c := range match {
			cases := []string{}
			for _, name := range c.names {
				switch typeDict[name] {
				case token.STRING:
					cases = append(cases, fmt.Sprintf("$null -ne $%s", name))
				case token.BOOL:
					cases = append(cases, fmt.Sprintf("$%s -ne $false", name))
				}
			}
			matchStmt.Cond = &psast.Ident{Name: strings.Join(cases, " -and ")}
			if len(c.body) > 0 {
				lines := strings.Split(c.body, "\n")
				for i, line := range lines {
					if i == len(lines)-1 && len(line) == 0 {
						continue
					}
					matchStmt.Body.List = append(matchStmt.Body.List, &psast.CallStmt{Func: &psast.Ident{Name: line}})
				}
			}
			matchStmt.Body.List = append(matchStmt.Body.List, &psast.CallStmt{Func: &psast.Ident{Name: "exit"}})
			if i != len(match)-1 {
				ifstmt := &psast.IfStmt{Body: &psast.BlockStmt{}}
				matchStmt.Else = ifstmt
				matchStmt = ifstmt
			}
		}

		if defaultMatchCase != nil {
			matchStmt.Else = &psast.BlockStmt{
				List: []psast.Stmt{
					&psast.ExprStmt{X: &psast.Ident{Name: defaultMatchCase.body}},
				},
			}
		}
	}
	return bs
}

func translate2Bash(ident, cmdName string, level int, cmd *cfg.Command) bashast.Node {
	subCommand := []bashast.Stmt{}
	for name, subcmd := range cmd.Command {
		subNode := translate2Bash(fmt.Sprintf("%s_%s", ident, name), name, level+1, subcmd)
		if subNode, ok := subNode.([]bashast.Stmt); ok {
			subCommand = append(subCommand, subNode...)
		}
	}
	bs := []bashast.Stmt{}
	if level > 0 {
		ifStmt := &bashast.IfStmt{Body: &bashast.BlockStmt{}}
		bs = append(bs, ifStmt)
		ifStmt.Cond = &bashast.BinaryExpr{X: &bashast.RefExpr{X: &bashast.IndexExpr{X: &bashast.Ident{Name: "args"}, Key: &bashast.BasicExpr{Kind: bashtoken.NUMBER, Value: "0"}}}, Op: bashtoken.EQ, Y: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: cmdName}}
		ifStmt.Body.List = append(ifStmt.Body.List, &bashast.ExprStmt{X: &bashast.Ident{Name: `args=("${args[@]:1}")`}})

		ifStmt.Body.List = append(ifStmt.Body.List, bashBlockStmtBuild(subCommand, ident, cmd)...)
	} else {
		bs = bashBlockStmtBuild(subCommand, ident, cmd)
	}

	return bs
}

func bashBlockStmtBuild(subCommand []bashast.Stmt, ident string, cmd *cfg.Command) (bs []bashast.Stmt) {
	for i, sc := range subCommand {
		if i == 0 {
			if i != len(subCommand)-1 {
				bs = append(bs, &bashast.AssignStmt{Lhs: &bashast.Ident{Name: fmt.Sprintf("temp_args_%s", ident)}, Rhs: &bashast.Ident{Name: `("${args[@]}")`}})
			}
			bs = append(bs, sc)
		} else {
			bs = append(bs, &bashast.AssignStmt{Lhs: &bashast.Ident{Name: "args"}, Rhs: &bashast.Ident{Name: fmt.Sprintf(`("${temp_args_%s[@]}")`, ident)}})
			bs = append(bs, sc)
		}
	}

	// init variables
	typeDict := map[string]token.Token{}
	for _, flag := range cmd.Flags {
		flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
		switch flag.Type {
		case "string":
			typeDict[flagIdent] = token.STRING
			bs = append(bs, &bashast.AssignStmt{Lhs: bashast.NewIdent(flagIdent), Rhs: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: ""}})
		case "bool":
			typeDict[flagIdent] = token.BOOL
			bs = append(bs, &bashast.AssignStmt{Lhs: bashast.NewIdent(flagIdent), Rhs: bashast.FALSE})
		}
	}
	bs = append(bs, bashast.NewExprStmt("non_matched_args=()"))

	if len(cmd.Flags) > 0 {
		forStmt := &bashast.ForStmt{
			Init: &bashast.BinaryExpr{X: &bashast.Ident{Name: "i"}, Op: bashtoken.ASSIGN, Y: &bashast.BasicExpr{Kind: bashtoken.NUMBER, Value: "0"}},
			Cond: &bashast.BinaryExpr{X: &bashast.Ident{Name: "i"}, Op: bashtoken.LT, Y: &bashast.Ident{Name: "${#args[@]}"}},
			Post: &bashast.IncDecExpr{X: &bashast.Ident{Name: "i"}, Op: bashtoken.Inc},
			Body: &bashast.BlockStmt{}}
		bs = append(bs, forStmt)
		switchStmt := &bashast.SwitchStmt{
			Cond: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: "${args[i]}"},
			Default: &bashast.CaseStmt{
				Body: &bashast.BlockStmt{
					List: []bashast.Stmt{
						bashast.NewExprStmt("non_matched_args+=(\"${args[i]}\")"),
					},
				},
			},
		}
		forStmt.Body.List = append(forStmt.Body.List, switchStmt)

		for _, flag := range cmd.Flags {
			flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
			alias := []string{}
			if len(flag.Alias) == 0 {
				alias = append(alias, flag.Name)
			} else {
				alias = append(alias, flag.Alias...)
			}
			for i, a := range alias {
				alias[i] = regexp.QuoteMeta(a)
			}
			rule := strings.Join(alias, "|")
			caseStmt := &bashast.CaseStmt{
				Cond: &bashast.Ident{Name: rule},
				Body: &bashast.BlockStmt{},
			}
			switchStmt.Cases = append(switchStmt.Cases, caseStmt)
			switch flag.Type {
			case "string":
				caseStmt.Body.List = append(caseStmt.Body.List, &bashast.AssignStmt{
					Lhs: bashast.NewIdent(flagIdent),
					Rhs: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: "${args[i+1]}"},
				})
				caseStmt.Body.List = append(caseStmt.Body.List, &bashast.ExprStmt{X: &bashast.Ident{Name: "((i++))"}})
			case "bool":
				caseStmt.Body.List = append(caseStmt.Body.List, &bashast.AssignStmt{
					Lhs: bashast.NewIdent(flagIdent),
					Rhs: bashast.TRUE,
				})
				// caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
				// 	X: &psast.IncDecExpr{
				// 		X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
				// 		Op: token.Inc,
				// 	},
				// })
			}
		}

		type sortedMatchCase struct {
			weight int
			names  []string
			body   string
		}

		match := []sortedMatchCase{}
		var defaultMatchCase *sortedMatchCase
		for _, matchCase := range cmd.Match {
			if len(matchCase.Platform) > 0 && matchCase.Platform != "bash" {
				continue
			}
			names := []string{}
			matchCase.Run = indexArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := indexArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					i, _ := strconv.Atoi(matched[0][1])
					i--
					return fmt.Sprintf(`"$($args[%d])"`, i)
				}
				return s
			})
			matchCase.Run = namedArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := namedArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					// shellcheck: Double quote to prevent globbing and word splitting.
					return fmt.Sprintf("$%s_%s", ident, matched[0][1])
				}
				return s
			})
			matchCase.Run = envArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := envArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					return fmt.Sprintf("$%s", matched[0][1])
				}
				return s
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					defaultMatchCase = &sortedMatchCase{
						body: matchCase.Run,
					}
					continue
				}
				names = append(names, fmt.Sprintf("%s_%s", ident, pattern))
			case []any:
				for _, v := range pattern {
					if v, ok := v.(string); ok {
						names = append(names, fmt.Sprintf("%s_%s", ident, v))
					}
				}
			}
			if len(names) != 0 {
				match = append(match, sortedMatchCase{weight: len(names), names: names, body: matchCase.Run})
			}
		}

		if len(match) == 0 {
			return bs
		}

		sort.Slice(match, func(i, j int) bool {
			return match[i].weight > match[j].weight
		})

		matchStmt := bashast.NewIfStmt()
		bs = append(bs, matchStmt)
		for i, c := range match {
			cases := []string{}
			for _, name := range c.names {
				switch typeDict[name] {
				case token.STRING:
					cases = append(cases, fmt.Sprintf(`-n "$%s"`, name))
				case token.BOOL:
					cases = append(cases, fmt.Sprintf("$%s == true", name))
				}
			}

			matchStmt.Cond = bashast.NewIdent(strings.Join(cases, " && "))
			if len(c.body) > 0 {
				lines := strings.Split(c.body, "\n")
				for i, line := range lines {
					if i == len(lines)-1 && len(line) == 0 {
						continue
					}
					matchStmt.Body.List = append(matchStmt.Body.List, bashast.NewCallStmt(line))
				}
			}
			matchStmt.Body.List = append(matchStmt.Body.List, bashast.NewCallStmt("exit"))
			if i != len(match)-1 {
				ifstmt := bashast.NewIfStmt()
				matchStmt.Else = ifstmt
				matchStmt = ifstmt
			}
		}

		if defaultMatchCase != nil {
			matchStmt.Else = &bashast.BlockStmt{
				List: []bashast.Stmt{
					bashast.NewExprStmt(defaultMatchCase.body),
				},
			}
		}
	}
	return
}
