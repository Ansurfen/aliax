// Copyright 2025 The Aliax Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package cmd

import (
	"aliax/internal/aos"
	bashast "aliax/internal/ast/bash"
	psast "aliax/internal/ast/powershell"
	"aliax/internal/cfg"
	"aliax/internal/shell"
	"aliax/internal/style"
	bashtoken "aliax/internal/token/bash"
	token "aliax/internal/token/powershell"
	"errors"
	"path/filepath"
	"runtime"
	"time"

	"fmt"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/ansurfen/globalenv"
	"github.com/caarlos0/log"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

// initCmdParameter stores parameters for the "init" command.
type initCmdParameter struct {
	global   bool
	force    bool
	verbose  bool
	template string
	save     bool
}

var (
	initParameter initCmdParameter
	initCmd       = &cobra.Command{
		Use:   "init",
		Short: "Initialize the aliax workspace and generate execution scripts",
		Long: `The "init" command scans the aliax configuration file and generates necessary execution scripts.
It creates platform-specific scripts in the "run-scripts" directory for alias commands and extensions.
If the --global (-g) flag is set, it applies configurations globally.`,
		Example: "  aliax init\n  aliax init --global",
		Run: func(cmd *cobra.Command, args []string) {
			var start time.Time
			if initParameter.verbose {
				start = time.Now()
				log.SetLevel(log.DebugLevel)
			}
			if len(initParameter.template) > 0 {
				config = filepath.Join(aos.TemplatePath, initParameter.template+".yaml")
			}
			var file cfg.Aliax
			err := aos.ReadYAML(config, &file)
			if err != nil {
				log.WithError(err).Fatalf("fail to parse file")
			}
			if initParameter.save {
				path := filepath.Join(aos.TemplatePath, filepath.Base(config))
				output, err := aos.Create(path)
				if err != nil {
					log.WithError(err).Fatal("fail to create file")
				}
				err = yaml.NewEncoder(output).Encode(file)
				if err != nil {
					log.WithError(err).Fatal("backuping template")
				}
			}
			err = aos.MkdirAll("run-scripts/bash", 0755)
			if err != nil {
				if errors.Is(err, os.ErrExist) {
					log.WithError(err).Warn("making run-scripts directory")
				} else {
					log.WithError(err).Fatal("making run-scripts directory")
				}
			}

			extBins := map[string]string{}

			for name, ext := range file.Extend {
				if len(ext.Bin) == 0 {
					ext.Bin, err = shell.LookPath(name)
					if err != nil {
						log.WithError(err).WithField("suggestion", "please make sure the executable exists,\neither by adding the bin field to the YAML to manually indicate the path,\nor by moving the extend to command").Fatal("looking path")
					}
				} else {
					if runtime.GOOS == "windows" {
						ext.Bin = envResolver.apply(ext.Bin, func(matched string) string {
							return fmt.Sprintf("$env:%s", matched)
						})
					} else {
						ext.Bin = envResolver.apply(ext.Bin, func(matched string) string {
							return fmt.Sprintf("$%s", matched)
						})
					}
				}
				extBins[name] = ext.Bin
				file.Extend[name].Bin = ext.Bin
			}

			buildExtend(file.Extend)

			buildCommand(file.Command)

			if initParameter.global {
				if err = setGlobal(); err != nil {
					log.WithError(err).Fatal("setting for the global")
				} else {
					data, err := getAliaxPath()
					if err != nil && !errors.Is(err, errAliaxPathNotFound) {
						log.WithError(err).Fatal("setting environment")
					}
					for k, v := range extBins {
						data[k] = v
					}
					output, err := setAliaxPath(data)
					if err != nil {
						log.WithField("output", string(output)).WithError(err).Fatal("setting environment")
					}
					log.Info("setting for the global")
				}
			}
			if initParameter.verbose {
				duration := time.Since(start)
				log.Debugf("executing succeded after %s", style.Bold(duration.String()))
			}
		},
	}
)

func buildExtend(cmds map[string]*cfg.Command) {
	for name, cmd := range cmds {
		filename := fmt.Sprintf("./run-scripts/%s.ps1", name)
		psFile, err := aos.Create(filename)
		if err != nil {
			if errors.Is(err, os.ErrExist) && !initParameter.force {
				log.WithError(err).
					WithField("file", filename).
					WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
						style.Keyword("aliax clean"),
						style.Keyword("-f"))).
					Fatal("file already exist")
			} else {
				log.WithError(err).Fatal("fail to create file")
			}
		}

		psNode := &psast.File{}
		psNode.Stmts = append(psNode.Stmts, &psast.Comment{
			Text: "Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
		})
		psNode.Stmts = append(psNode.Stmts, &psast.AssignStmt{
			Lhs: psast.RefRaw("executable"),
			Rhs: psast.String(cmd.Bin),
		})
		cmd.DisableHelp = true
		if bs, ok := translate2Powershell(name, name, 0, cmd).([]psast.Stmt); ok {
			psNode.Stmts = append(psNode.Stmts, bs...)
		}
		psNode.Stmts = append(psNode.Stmts, &psast.CallStmt{
			CallOp: token.BITAND,
			Func:   psast.RefRaw("executable"),
			Recv:   []psast.Expr{psast.RefRaw("args")},
		})
		psast.Print(psNode, psFile)
		psFile.Close()

		filename = fmt.Sprintf("./run-scripts/%s.sh", name)

		shFile, err := aos.Create(filename)
		if err != nil {
			if errors.Is(err, os.ErrExist) && !initParameter.force {
				log.WithError(err).
					WithField("file", filename).
					WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
						style.Keyword("aliax clean"),
						style.Keyword("-f"))).
					Fatal("file already exist")
			} else {
				log.WithError(err).Fatal("fail to create file")
			}
		}

		shNode := &bashast.File{}
		shNode.Stmts = append(shNode.Stmts, &bashast.Comment{
			Text: "!/bin/bash",
		}, &bashast.Comment{
			Text: " Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
		}, &bashast.ExprStmt{X: bashast.Identifier("set -e")})
		shNode.Stmts = append(shNode.Stmts, &bashast.AssignStmt{
			Lhs: bashast.Identifier("executable"),
			Rhs: bashast.String(cmd.Bin),
		})
		shNode.Stmts = append(shNode.Stmts, &bashast.ExprStmt{X: bashast.Raw(`args=("$@")`)})
		if bs, ok := translate2Bash(name, name, 0, cmd).([]bashast.Stmt); ok {
			shNode.Stmts = append(shNode.Stmts, bs...)
		}
		shNode.Stmts = append(shNode.Stmts,
			&bashast.CallStmt{
				Func: &bashast.RefExpr{X: bashast.Identifier("executable")},
				Recv: []bashast.Expr{bashast.Raw(`"${args[@]}"`)},
			})
		bashast.Print(shNode, shFile)
		shFile.Close()

		target, err := filepath.Abs(shFile.Name())
		if err != nil {
			log.WithError(err).Fatal("invalid path")
		}
		link := filepath.Join(filepath.Dir(target), "bash", strings.TrimSuffix(filepath.Base(target), ".sh"))

		if ok, _ := aos.Exist(link); ok && initParameter.force {
			log.WithField("link", link).Info("deleting old symbol link")
			err = os.Remove(link)
			if err != nil {
				log.WithError(err).Fatal("fail to delete file")
			}
		}
		if runtime.GOOS == "windows" {
			err = shell.Run("cmd", "/C", "mklink", link, target)
		} else {
			err = shell.Run("ln", "-s", target, link)
		}
		if err != nil {
			log.WithField("suggestion", fmt.Sprintf("If the error is that the file already exists,\nrun %s and try again", style.Keyword("aliax clean"))).Fatalf("creating symbol link for %s", target)
		}
	}
}

func buildCommand(cmds map[string]*cfg.Command) {
	for name, cmd := range cmds {
		err := cmd.Preload(name)
		if err != nil {
			log.WithError(err).Fatalf("preloading %s", name)
		}
		filename := fmt.Sprintf("./run-scripts/%s.ps1", name)
		psFile, err := aos.Create(filename)
		if err != nil {
			if errors.Is(err, os.ErrExist) && !initParameter.force {
				log.WithError(err).
					WithField("file", filename).
					WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
						style.Keyword("aliax clean"),
						style.Keyword("-f"))).
					Fatal("file already exist")
			} else {
				log.WithError(err).Fatal("fail to create file")
			}
		}

		psNode := &psast.File{}
		psNode.Stmts = append(psNode.Stmts, psast.Docs("Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT"))

		cmd.SetName(name)
		if bs, ok := translate2Powershell(name, name, 0, cmd).([]psast.Stmt); ok {
			psNode.Stmts = append(psNode.Stmts, bs...)
		}

		psNode.Stmts = append(psNode.Stmts,
			psast.CallStatement(token.None, "Write-Host", psast.String(cmd.HelpCmd(name))))
		psast.Print(psNode, psFile)
		psFile.Close()

		filename = fmt.Sprintf("./run-scripts/%s.sh", name)

		shFile, err := aos.Create(filename)
		if err != nil {
			if errors.Is(err, os.ErrExist) && !initParameter.force {
				log.WithError(err).
					WithField("file", filename).
					WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
						style.Keyword("aliax clean"),
						style.Keyword("-f"))).
					Fatal("file already exist")
			} else {
				log.WithError(err).Fatal("fail to create file")
			}
		}

		shNode := &bashast.File{}
		shNode.Stmts = append(shNode.Stmts,
			bashast.Docs("!/bin/bash"),
			bashast.Docs(" Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT"),
			bashast.RawStmt("set -e"))

		shNode.Stmts = append(shNode.Stmts, &bashast.ExprStmt{X: bashast.Raw(`args=("$@")`)})
		if bs, ok := translate2Bash(name, name, 0, cmd).([]bashast.Stmt); ok {
			shNode.Stmts = append(shNode.Stmts, bs...)
		}
		shNode.Stmts = append(shNode.Stmts,
			bashast.CallStatement("cat", fmt.Sprintf("<<EOF\n%s\nEOF", cmd.HelpCmd(name))))
		bashast.Print(shNode, shFile)
		shFile.Close()

		target, err := filepath.Abs(shFile.Name())
		if err != nil {
			log.WithError(err).Fatal("invalid path")
		}
		link := filepath.Join(filepath.Dir(target), "bash", strings.TrimSuffix(filepath.Base(target), ".sh"))

		if ok, _ := aos.Exist(link); ok && initParameter.force {
			log.WithField("link", link).Info("deleting old symbol link")
			err = os.Remove(link)
			if err != nil {
				log.WithError(err).Fatal("fail to delete file")
			}
		}
		if runtime.GOOS == "windows" {
			err = shell.Run("cmd", "/C", "mklink", link, target)
		} else {
			err = shell.Run("ln", "-s", target, link)
		}
		if err != nil {
			log.WithField("suggestion", fmt.Sprintf("If the error is that the file already exists,\nrun %s and try again", style.Keyword("aliax clean"))).Fatalf("creating symbol link for %s", target)
		}
	}
}

func init() {
	aliaxCmd.AddCommand(initCmd)
	initCmd.PersistentFlags().BoolVarP(&initParameter.global, "global", "g", false, "Apply the initialization globally, affecting the entire system instead of the current project")
	initCmd.PersistentFlags().BoolVarP(&initParameter.force, "force", "f", false, "Force the initialization, bypassing confirmation prompts")
	initCmd.PersistentFlags().BoolVarP(&initParameter.verbose, "verbose", "v", false, "Enable verbose output")
	initCmd.PersistentFlags().StringVarP(&initParameter.template, "template", "t", "", "Specify a template to use for initialization")
	initCmd.PersistentFlags().BoolVarP(&initParameter.save, "save", "s", false, "Backup the current executed YAML to the template directory")
}

var (
	namedResolver = newResolver(`\{\{\s*\.(\w+)\s*\}\}`)
	indexResolver = newResolver(`\{\{\s*\$(\d+)\s*\}\}`)
	envResolver   = newResolver(`\{\{\s*\$\w+\.(\w+)\s*\}\}`)
)

type resolver struct {
	pattern *regexp.Regexp
}

func newResolver(str string) *resolver {
	return &resolver{
		pattern: regexp.MustCompile(str),
	}
}

func (r *resolver) apply(raw string, hd func(matched string) string) string {
	return r.pattern.ReplaceAllStringFunc(raw, func(s string) string {
		matched := r.pattern.FindAllStringSubmatch(s, -1)
		if len(matched) > 0 && len(matched[0]) > 1 {
			return hd(matched[0][1])
		}
		return s
	})
}

func setGlobal() error {
	var (
		value string
		err   error
	)
	if runtime.GOOS == "windows" {
		value, err = globalenv.Get("Path")
	} else {
		value, err = globalenv.Get("PATH")
	}
	if err != nil {
		return err
	}
	path, err := os.Getwd()
	if err != nil {
		return err
	}
	path = filepath.Join(path, "run-scripts")
	if !strings.Contains(value, path) {
		var output []byte
		if runtime.GOOS == "windows" {
			output, err = globalenv.Set("Path", fmt.Sprintf("%s;%s", path, value))
		} else {
			output, err = globalenv.Set("PATH", fmt.Sprintf("$PATH:%s", path))
		}
		if err != nil {
			log.WithField("output", string(output)).Error("setting Path")
			return err
		}
	}
	log.WithField("path", path).Warn("the environment variable is already set")
	return nil
}

func translate2Powershell(ident, cmdName string, level int, cmd *cfg.Command) psast.Node {
	subCommand := []psast.Stmt{}
	for name, subcmd := range cmd.Command {
		subcmd.SetName(name)
		// TODO: fix extend bug
		subcmd.DisableHelp = cmd.DisableHelp
		subNode := translate2Powershell(fmt.Sprintf("%s_%s", ident, name), name, level+1, subcmd)
		if subNode, ok := subNode.([]psast.Stmt); ok {
			subCommand = append(subCommand, subNode...)
		}
	}
	bs := []psast.Stmt{}
	if level > 0 {
		ifStmt := psast.IfStatement()
		bs = append(bs, ifStmt)
		ifStmt.Cond = psast.BinaryExpression(psast.RefExpression(psast.IndexExpression(psast.Identifier("args"), psast.Number(0))), token.EQ, psast.String(cmdName))
		ifStmt.Body.List = append(ifStmt.Body.List, &psast.AssignStmt{Lhs: psast.RefRaw("args"), Rhs: &psast.RefExpr{X: &psast.IndexExpr{X: psast.Identifier("args"), Key: &psast.BinaryExpr{X: psast.Number(1), Op: token.DOUBLE_DOT, Y: &psast.RefExpr{X: &psast.SelectorExpr{X: psast.Identifier("args"), Sel: psast.Identifier("Length")}}}}}})
		ifStmt.Body.List = append(ifStmt.Body.List, psBlockStmtBuild(subCommand, ident, cmd)...)
	} else {
		bs = psBlockStmtBuild(subCommand, ident, cmd)
	}

	return bs
}

type sortedMatchCase struct {
	weight int
	names  []string
	body   string
}

type bashBuilder struct {
}

type psBuilder struct {
}

func psBlockStmtBuild(subCommand []psast.Stmt, ident string, cmd *cfg.Command) (bs []psast.Stmt) {
	for i, sc := range subCommand {
		if i == 0 {
			if i != len(subCommand)-1 {
				bs = append(bs, psast.AssignStatement(psast.RefRaw(fmt.Sprintf("temp_args_%s", ident)), psast.RefRaw("args")))
			}
			bs = append(bs, sc)
		} else {
			bs = append(bs, psast.AssignStatement(psast.RefRaw("args"), psast.RefRaw(fmt.Sprintf("temp_args_%s", ident))))
			bs = append(bs, sc)
		}
	}

	// init variables
	typeDict := map[string]token.Token{}
	for _, flag := range cmd.Flags {
		flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
		switch flag.Type {
		case "string":
			typeDict[flagIdent] = token.STRING
			bs = append(bs, psast.AssignStatement(psast.RefRaw(flagIdent), psast.Null))
		case "bool":
			typeDict[flagIdent] = token.BOOL
			bs = append(bs, psast.AssignStatement(psast.RefRaw(flagIdent), psast.False))
		}
	}
	bs = append(bs, psast.AssignStatement(psast.RefRaw("non_matched_args"), psast.Raw("@()")))

	if len(cmd.Flags) > 0 {
		forStmt := psast.ForStatement(
			psast.BinaryExpression(psast.RefRaw("i"), token.ASSIGN, psast.Number(0)),
			psast.BinaryExpression(psast.RefRaw("i"), token.LT, psast.RefExpression(psast.SelectorExpression(psast.Identifier("args"), psast.Identifier("Length")))),
			psast.IncDecExpression("i", true),
		)
		bs = append(bs, forStmt)

		switchStmt := &psast.SwitchStmt{
			Regex: true,
			Cond:  psast.RefExpression(psast.IndexExpression(psast.Identifier("args"), psast.RefRaw("i"))),
			Default: &psast.CaseStmt{
				Body: &psast.BlockStmt{
					List: []psast.Stmt{
						&psast.ExprStmt{
							X: psast.BinaryExpression(
								psast.RefRaw("non_matched_args"),
								token.ADD_ASSIGN,
								psast.Raw("$args[$i]"),
							),
						},
					},
				},
			},
		}
		forStmt.Body.Append(switchStmt)

		for _, flag := range cmd.Flags {
			flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
			alias := []string{}
			if len(flag.Alias) == 0 {
				alias = append(alias, flag.Name)
			} else {
				alias = append(alias, flag.Alias...)
			}
			for i, a := range alias {
				alias[i] = regexp.QuoteMeta(a)
			}
			rule := strings.Join(alias, "|")
			caseStmt := psast.CaseStatement(psast.String(rule))
			switchStmt.Cases = append(switchStmt.Cases, caseStmt)
			switch flag.Type {
			case "string":
				caseStmt.Body.Append(
					psast.AssignStatement(
						psast.RefRaw(flagIdent),
						psast.IndexExpression(
							psast.RefRaw("args"), psast.BinaryExpression(psast.RefRaw("i"), token.ADD, psast.Number(1)))))
				caseStmt.Body.Append(&psast.ExprStmt{X: psast.IncDecExpression("i", true)})
			case "bool":
				caseStmt.Body.Append(psast.AssignStatement(psast.RefRaw(flagIdent), psast.True))
				// caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
				// 	X: &psast.IncDecExpr{
				// 		X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
				// 		Op: token.Inc,
				// 	},
				// })
			}
		}

		match := []sortedMatchCase{}
		var defaultMatchCase *sortedMatchCase
		for _, matchCase := range cmd.Match {
			if len(matchCase.Platform) > 0 && matchCase.Platform != "powershell" {
				continue
			}
			names := []string{}
			matchCase.Run = indexResolver.apply(matchCase.Run, func(matched string) string {
				i, _ := strconv.Atoi(matched)
				i--
				return fmt.Sprintf(`"$($args[%d])"`, i)
			})
			matchCase.Run = namedResolver.apply(matchCase.Run, func(matched string) string {
				return fmt.Sprintf("$%s_%s", ident, matched)
			})
			matchCase.Run = envResolver.apply(matchCase.Run, func(matched string) string {
				return fmt.Sprintf("$env:%s", matched)
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					defaultMatchCase = &sortedMatchCase{
						body: matchCase.Run,
					}
					continue
				}
				names = append(names, fmt.Sprintf("%s_%s", ident, pattern))
			case []any:
				for _, v := range pattern {
					if v, ok := v.(string); ok {
						names = append(names, fmt.Sprintf("%s_%s", ident, v))
					}
				}
			}
			if len(names) != 0 {
				match = append(match, sortedMatchCase{weight: len(names), names: names, body: matchCase.Run})
			}
		}

		if len(match) == 0 {
			return bs
		}

		sort.Slice(match, func(i, j int) bool {
			return match[i].weight > match[j].weight
		})

		matchStmt := psast.IfStatement()
		bs = append(bs, matchStmt)
		for i, c := range match {
			var cases psast.Expr
			for _, name := range c.names {
				var cond psast.Expr
				switch typeDict[name] {
				case token.STRING:
					cond = psast.BinaryExpression(
						psast.Null,
						token.NE,
						psast.RefRaw(name),
					)
				case token.BOOL:
					cond = psast.BinaryExpression(
						psast.RefRaw(name),
						token.NE,
						psast.False,
					)
				}

				if cases == nil {
					cases = cond
				} else {
					cases = psast.BinaryExpression(cases, token.AND, cond)
				}
			}
			matchStmt.Cond = cases
			if len(c.body) > 0 {
				lines := strings.Split(c.body, "\n")
				for i, line := range lines {
					if i == len(lines)-1 && len(line) == 0 {
						continue
					}
					matchStmt.Body.Append(psast.CallStatement(token.None, line))
				}
			}
			matchStmt.Body.Append(psast.CallStatement(token.None, "exit"))
			if i != len(match)-1 {
				ifstmt := psast.IfStatement()
				matchStmt.Else = ifstmt
				matchStmt = ifstmt
			}
		}

		if defaultMatchCase != nil {
			matchStmt.Else = &psast.BlockStmt{
				List: []psast.Stmt{
					&psast.ExprStmt{X: psast.Identifier(defaultMatchCase.body)},
				},
			}
		}

		if !cmd.DisableHelp {
			bs = append(bs,
				psast.CallStatement(token.None, "Write-Host", psast.String(cmd.HelpCmd(cmd.Name()))),
				psast.CallStatement(token.None, "exit"))
		}
	} else {
		for _, matchCase := range cmd.Match {
			matchCase.Run = indexResolver.apply(matchCase.Run, func(matched string) string {
				i, err := strconv.Atoi(matched)
				if err != nil {
					log.WithError(err).Fatal("evaluating value")
				}
				i--
				return fmt.Sprintf(`"$($args[%d])"`, i)
			})
			matchCase.Run = envResolver.apply(matchCase.Run, func(matched string) string {
				return fmt.Sprintf("$env:%s", matched)
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					bs = append(bs,
						psast.CallStatement(token.None, matchCase.Run),
						psast.CallStatement(token.None, "exit"))
				}
			}
		}
	}
	return bs
}

func translate2Bash(ident, cmdName string, level int, cmd *cfg.Command) bashast.Node {
	subCommand := []bashast.Stmt{}
	for name, subcmd := range cmd.Command {
		subcmd.SetName(name)
		// TODO fix extend bug
		subcmd.DisableHelp = cmd.DisableHelp
		subNode := translate2Bash(fmt.Sprintf("%s_%s", ident, name), name, level+1, subcmd)
		if subNode, ok := subNode.([]bashast.Stmt); ok {
			subCommand = append(subCommand, subNode...)
		}
	}
	bs := []bashast.Stmt{}
	if level > 0 {
		ifStmt := &bashast.IfStmt{Body: &bashast.BlockStmt{}}
		bs = append(bs, ifStmt)
		ifStmt.Cond = &bashast.BinaryExpr{X: &bashast.RefExpr{X: &bashast.IndexExpr{X: &bashast.Ident{Name: "args"}, Key: &bashast.BasicExpr{Kind: bashtoken.NUMBER, Value: "0"}}}, Op: bashtoken.EQ, Y: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: cmdName}}
		ifStmt.Body.List = append(ifStmt.Body.List, &bashast.ExprStmt{X: &bashast.Ident{Name: `args=("${args[@]:1}")`}})

		ifStmt.Body.List = append(ifStmt.Body.List, bashBlockStmtBuild(subCommand, ident, cmd)...)
	} else {
		bs = bashBlockStmtBuild(subCommand, ident, cmd)
	}

	return bs
}

func bashBlockStmtBuild(subCommand []bashast.Stmt, ident string, cmd *cfg.Command) (bs []bashast.Stmt) {
	for i, sc := range subCommand {
		if i == 0 {
			if i != len(subCommand)-1 {
				bs = append(bs, bashast.AssignStatement(bashast.Identifier(fmt.Sprintf("temp_args_%s", ident)), bashast.Raw(`("${args[@]}")`)))
			}
			bs = append(bs, sc)
		} else {
			bs = append(bs, bashast.AssignStatement(bashast.Identifier("args"), bashast.Raw(fmt.Sprintf(`("${temp_args_%s[@]}")`, ident))))
			bs = append(bs, sc)
		}
	}

	// init variables
	typeDict := map[string]token.Token{}
	for _, flag := range cmd.Flags {
		flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
		switch flag.Type {
		case "string":
			typeDict[flagIdent] = token.STRING
			bs = append(bs, bashast.AssignStatement(bashast.Identifier(flagIdent), bashast.String("")))
		case "bool":
			typeDict[flagIdent] = token.BOOL
			bs = append(bs, bashast.AssignStatement(bashast.Identifier(flagIdent), bashast.FALSE))
		}
	}
	bs = append(bs, bashast.RawStmt("non_matched_args=()"))

	if len(cmd.Flags) > 0 {
		forStmt := bashast.ForStatement(
			bashast.BinaryExpression(bashast.Identifier("i"), bashtoken.ASSIGN, bashast.Number(0)),
			bashast.BinaryExpression(bashast.Identifier("i"), bashtoken.LT, bashast.Raw("${#args[@]}")),
			bashast.IncDecExpression(bashast.Identifier("i"), true),
		)
		bs = append(bs, forStmt)
		switchStmt := &bashast.SwitchStmt{
			Cond: bashast.String("${args[i]}"),
			Default: &bashast.CaseStmt{
				Body: &bashast.BlockStmt{
					List: []bashast.Stmt{
						bashast.RawStmt("non_matched_args+=(\"${args[i]}\")"),
					},
				},
			},
		}
		forStmt.Body.Append(switchStmt)

		for _, flag := range cmd.Flags {
			flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
			alias := []string{}
			if len(flag.Alias) == 0 {
				alias = append(alias, flag.Name)
			} else {
				alias = append(alias, flag.Alias...)
			}
			for i, a := range alias {
				alias[i] = regexp.QuoteMeta(a)
			}
			rule := strings.Join(alias, "|")
			caseStmt := bashast.CaseStatement(bashast.Identifier(rule))
			switchStmt.Cases = append(switchStmt.Cases, caseStmt)
			switch flag.Type {
			case "string":
				caseStmt.Body.Append(
					bashast.AssignStatement(bashast.Identifier(flagIdent), bashast.String("${args[i+1]}")),
					bashast.RawStmt("((i++))"))
			case "bool":
				caseStmt.Body.Append(bashast.AssignStatement(bashast.Identifier(flagIdent), bashast.TRUE))
				// caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
				// 	X: &psast.IncDecExpr{
				// 		X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
				// 		Op: token.Inc,
				// 	},
				// })
			}
		}

		type sortedMatchCase struct {
			weight int
			names  []string
			body   string
		}

		match := []sortedMatchCase{}
		var defaultMatchCase *sortedMatchCase
		for _, matchCase := range cmd.Match {
			if len(matchCase.Platform) > 0 && matchCase.Platform != "bash" {
				continue
			}
			names := []string{}
			matchCase.Run = indexResolver.apply(matchCase.Run, func(matched string) string {
				i, _ := strconv.Atoi(matched)
				i--
				return fmt.Sprintf(`"$($args[%d])"`, i)
			})
			matchCase.Run = namedResolver.apply(matchCase.Run, func(matched string) string {
				// shellcheck: Double quote to prevent globbing and word splitting.
				return fmt.Sprintf("$%s_%s", ident, matched)
			})
			matchCase.Run = envResolver.apply(matchCase.Run, func(matched string) string {
				return fmt.Sprintf("$%s", matched)
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					defaultMatchCase = &sortedMatchCase{
						body: matchCase.Run,
					}
					continue
				}
				names = append(names, fmt.Sprintf("%s_%s", ident, pattern))
			case []any:
				for _, v := range pattern {
					if v, ok := v.(string); ok {
						names = append(names, fmt.Sprintf("%s_%s", ident, v))
					}
				}
			}
			if len(names) != 0 {
				match = append(match, sortedMatchCase{weight: len(names), names: names, body: matchCase.Run})
			}
		}

		if len(match) == 0 {
			return bs
		}

		sort.Slice(match, func(i, j int) bool {
			return match[i].weight > match[j].weight
		})

		matchStmt := bashast.IfStatement()
		bs = append(bs, matchStmt)
		for i, c := range match {
			var cases bashast.Expr
			for _, name := range c.names {
				var cond bashast.Expr
				switch typeDict[name] {
				case token.STRING:
					cond = bashast.Raw(fmt.Sprintf(`-n "$%s"`, name))
				case token.BOOL:
					cond = bashast.BinaryExpression(
						bashast.RefRaw(name),
						bashtoken.EQ,
						bashast.TRUE,
					)
				}
				if cases == nil {
					cases = cond
				} else {
					cases = bashast.BinaryExpression(cases, bashtoken.AND, cond)
				}
			}

			matchStmt.Cond = cases
			if len(c.body) > 0 {
				lines := strings.Split(c.body, "\n")
				for i, line := range lines {
					if i == len(lines)-1 && len(line) == 0 {
						continue
					}
					matchStmt.Body.Append(bashast.CallStatement(line))
				}
			}
			matchStmt.Body.Append(bashast.CallStatement("exit"))
			if i != len(match)-1 {
				ifstmt := bashast.IfStatement()
				matchStmt.Else = ifstmt
				matchStmt = ifstmt
			}
		}

		if defaultMatchCase != nil {
			matchStmt.Else = bashast.BlockStatement(bashast.RawStmt(defaultMatchCase.body))
		}

		if !cmd.DisableHelp {
			bs = append(bs, bashast.CallStatement("cat",
				fmt.Sprintf("<<EOF\n%s\nEOF", cmd.HelpCmd(cmd.Name()))),
				bashast.CallStatement("exit"))
		}
	} else {
		for _, matchCase := range cmd.Match {
			matchCase.Run = indexResolver.apply(matchCase.Run, func(matched string) string {
				i, _ := strconv.Atoi(matched)
				i--
				return fmt.Sprintf(`"$($args[%d])"`, i)
			})
			matchCase.Run = envResolver.apply(matchCase.Run, func(matched string) string {
				return fmt.Sprintf("$env:%s", matched)
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					bs = append(bs, bashast.CallStatement(matchCase.Run), bashast.CallStatement("exit"))
				}
			}
		}
	}
	return
}
