// Copyright 2025 The Aliax Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package cmd

import (
	bashast "aliax/internal/ast/bash"
	psast "aliax/internal/ast/powershell"
	"aliax/internal/cfg"
	"aliax/internal/aio"
	"aliax/internal/shell"
	"aliax/internal/style"
	bashtoken "aliax/internal/token/bash"
	token "aliax/internal/token/powershell"
	"errors"
	"path/filepath"
	"runtime"

	"fmt"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/ansurfen/globalenv"
	"github.com/caarlos0/log"
	"github.com/spf13/cobra"
)

// initCmdParameter stores parameters for the "init" command.
type initCmdParameter struct {
	global  bool
	force   bool
	verbose bool
}

var (
	initParameter initCmdParameter
	initCmd       = &cobra.Command{
		Use:   "init",
		Short: "Initialize the aliax workspace and generate execution scripts",
		Long: `The "init" command scans the aliax configuration file and generates necessary execution scripts.
It creates platform-specific scripts in the "run-scripts" directory for alias commands and extensions.
If the --global (-g) flag is set, it applies configurations globally.`,
		Example: "  aliax init\n  aliax init --global",
		Run: func(cmd *cobra.Command, args []string) {
			if initParameter.verbose {
				log.SetLevel(log.DebugLevel)
			}
			var file cfg.Aliax
			err := aio.ReadYAML(config, &file)
			if err != nil {
				log.WithError(err).Fatalf("parsing %s", config)
			}
			log.Infof("parsing %s", config)
			err = os.MkdirAll("run-scripts/bash", 0755)
			if err != nil {
				if errors.Is(err, os.ErrExist) {
					log.WithError(err).Warn("making run-scripts directory")
				} else {
					log.WithError(err).Fatal("making run-scripts directory")
				}
			}
			bins := map[string]string{}
			for name, cmd := range file.Extend {
				var bin string
				if len(cmd.Bin) == 0 {
					bin, err = exec.LookPath(name)
					if err != nil {
						log.WithError(err).Fatal("looking path")
					}
					cmd.Bin = bin
				} else {
					bin = envArguments.ReplaceAllStringFunc(cmd.Bin, func(s string) string {
						matched := envArguments.FindAllStringSubmatch(s, -1)
						if len(matched) > 0 && len(matched[0]) > 1 {
							return fmt.Sprintf("$env:%s", matched[0][1])
						}
						return s
					})
				}
				bins[name] = bin
				filename := fmt.Sprintf("./run-scripts/%s.ps1", name)

				log.Infof("creating %s", filename)
				if ok, _ := aio.Exist(filename); ok && !initParameter.force {
					log.WithError(os.ErrExist).
						WithField("file", filename).
						WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
							style.Keyword("aliax clean"),
							style.Keyword("-f"))).
						Fatal("file already exist")
				}
				psFile, err := os.Create(filename)
				if err != nil {
					log.WithError(err).Fatalf("fail to create file")
				}

				psNode := &psast.File{}
				psNode.Stmts = append(psNode.Stmts, &psast.Comment{
					Text: "Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
				})
				psNode.Stmts = append(psNode.Stmts, &psast.AssignStmt{
					Lhs: &psast.RefExpr{X: &psast.Ident{Name: "executable"}},
					Rhs: &psast.BasicExpr{Kind: token.STRING, Value: bin},
				})
				if bs, ok := translate2Powershell(name, name, 0, cmd).([]psast.Stmt); ok {
					psNode.Stmts = append(psNode.Stmts, bs...)
				}
				psNode.Stmts = append(psNode.Stmts, &psast.CallStmt{
					CallOp: token.AND,
					Func:   &psast.RefExpr{X: &psast.Ident{Name: "executable"}},
					Recv:   []psast.Expr{&psast.RefExpr{X: &psast.Ident{Name: "args"}}},
				})
				psast.Print(psNode, psFile)
				psFile.Close()

				bin = envArguments.ReplaceAllStringFunc(cmd.Bin, func(s string) string {
					matched := envArguments.FindAllStringSubmatch(s, -1)
					if len(matched) > 0 && len(matched[0]) > 1 {
						return fmt.Sprintf("$%s", matched[0][1])
					}
					return s
				})

				filename = fmt.Sprintf("./run-scripts/%s.sh", name)
				log.Infof("creating %s", filename)
				if ok, _ := aio.Exist(filename); ok && !initParameter.force {
					log.WithError(os.ErrExist).
						WithField("file", filename).
						WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
							style.Keyword("aliax clean"),
							style.Keyword("-f"))).
						Fatal("file already exist")
				}
				shFile, err := os.Create(filename)
				if err != nil {
					log.WithError(err).Fatalf("fail to create file")
				}
				shNode := &bashast.File{}
				shNode.Stmts = append(shNode.Stmts, &bashast.Comment{
					Text: "!/bin/bash",
				}, &bashast.Comment{
					Text: " Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
				})
				shNode.Stmts = append(shNode.Stmts, &bashast.AssignStmt{
					Lhs: &bashast.Ident{Name: "executable"},
					Rhs: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: bin},
				})
				shNode.Stmts = append(shNode.Stmts, &bashast.ExprStmt{X: &bashast.Ident{Name: `args=("$@")`}})
				if bs, ok := translate2Bash(name, name, 0, cmd).([]bashast.Stmt); ok {
					shNode.Stmts = append(shNode.Stmts, bs...)
				}
				shNode.Stmts = append(shNode.Stmts, &bashast.CallStmt{
					Func: &bashast.RefExpr{X: &bashast.Ident{Name: "executable"}},
					Recv: []bashast.Expr{&bashast.Ident{Name: `"${args[@]}"`}},
				})
				bashast.Print(shNode, shFile)
				shFile.Close()

				target, err := filepath.Abs(shFile.Name())
				if err != nil {
					log.WithError(err).Fatal("invalid path")
				}
				link := filepath.Join(filepath.Dir(target), "bash", strings.TrimSuffix(filepath.Base(target), ".sh"))

				if ok, _ := aio.Exist(link); ok && initParameter.force {
					log.WithField("link", link).Info("deleting old symbol link")
					err = os.Remove(link)
					if err != nil {
						log.WithError(err).Fatal("fail to delete file")
					}
				}
				if runtime.GOOS == "windows" {
					err = shell.Run("cmd", "/C", "mklink", link, target)
				} else {
					err = shell.Run("ln", "-s", target, link)
				}
				if err != nil {
					log.WithField("suggestion", fmt.Sprintf("If the error is that the file already exists,\nrun %s and try again", style.Keyword("aliax clean"))).Fatalf("creating symbol link for %s", target)
				}
			}

			for name, cmd := range file.Command {
				filename := fmt.Sprintf("./run-scripts/%s.ps1", name)
				log.Infof("creating %s", filename)
				if ok, _ := aio.Exist(filename); ok && !initParameter.force {
					log.WithError(os.ErrExist).
						WithField("file", filename).
						WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
							style.Keyword("aliax clean"),
							style.Keyword("-f"))).
						Fatal("file already exist")
				}
				psFile, err := os.Create(filename)
				if err != nil {
					log.WithError(err).Fatalf("fail to create file")
				}

				psNode := &psast.File{}
				psNode.Stmts = append(psNode.Stmts, &psast.Comment{
					Text: "Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
				})
				if bs, ok := translate2Powershell(name, name, 0, cmd).([]psast.Stmt); ok {
					psNode.Stmts = append(psNode.Stmts, bs...)
				}
				psast.Print(psNode, psFile)
				psFile.Close()

				filename = fmt.Sprintf("./run-scripts/%s.sh", name)
				log.Infof("creating %s", filename)
				if ok, _ := aio.Exist(filename); ok && !initParameter.force {
					log.WithError(os.ErrExist).
						WithField("file", filename).
						WithField("suggestion", fmt.Sprintf("\nplease run %s to clean up workspace, or add %s flag to execute forcibly",
							style.Keyword("aliax clean"),
							style.Keyword("-f"))).
						Fatal("file already exist")
				}
				shFile, err := os.Create(filename)
				if err != nil {
					log.WithError(err).Fatalf("fail to create file")
				}

				shNode := &bashast.File{}
				shNode.Stmts = append(shNode.Stmts, &bashast.Comment{
					Text: "!/bin/bash",
				}, &bashast.Comment{
					Text: " Code generated by [aliax](github.com/ansurfen/aliax). DO NOT EDIT",
				})
				shNode.Stmts = append(shNode.Stmts, &bashast.ExprStmt{X: &bashast.Ident{Name: `args=("$@")`}})
				if bs, ok := translate2Bash(name, name, 0, cmd).([]bashast.Stmt); ok {
					shNode.Stmts = append(shNode.Stmts, bs...)
				}
				bashast.Print(shNode, shFile)
				shFile.Close()

				target, err := filepath.Abs(shFile.Name())
				if err != nil {
					log.WithError(err).Fatal("invalid path")
				}
				link := filepath.Join(filepath.Dir(target), "bash", strings.TrimSuffix(filepath.Base(target), ".sh"))
				if ok, _ := aio.Exist(link); ok && initParameter.force {
					log.WithField("link", link).Info("deleting old symbol link")
					err = os.Remove(link)
					if err != nil {
						log.WithError(err).Fatal("fail to delete file")
					}
				}

				if runtime.GOOS == "windows" {
					err = shell.Run("cmd", "/C", "mklink", link, target)
				} else {
					err = shell.Run("ln", "-s", target, link)
				}
				if err != nil {
					log.Fatalf("creating symbol link for %s", target)
				}
			}

			if initParameter.global {
				if err = setGlobal(); err != nil {
					log.WithError(err).Fatal("setting for the global")
				} else {
					data, err := getAliaxPath()
					if err != nil && !errors.Is(err, errAliaxPathNotFound) {
						log.WithError(err).Fatal("setting environment")
					}
					for k, v := range bins {
						data[k] = v
					}
					output, err := setAliaxPath(data)
					if err != nil {
						log.WithField("output", string(output)).WithError(err).Fatal("setting environment")
					}
					log.Info("setting for the global")
				}
			}
			log.Info("thanks for using aliax!")
		},
	}
)

func init() {
	aliaxCmd.AddCommand(initCmd)
	initCmd.PersistentFlags().BoolVarP(&initParameter.global, "global", "g", false, "Apply the initialization globally, affecting the entire system instead of the current project")
	initCmd.PersistentFlags().BoolVarP(&initParameter.force, "force", "f", false, "")
}

var (
	namedArguments = regexp.MustCompile(`\{\{\s*\.(\w+)\s*\}\}`)
	indexArguments = regexp.MustCompile(`\{\{\s*\$(\d+)\s*\}\}`)
	envArguments   = regexp.MustCompile(`\{\{\s*\$\w+\.(\w+)\s*\}\}`)
)

func setGlobal() error {
	var (
		value string
		err   error
	)
	if runtime.GOOS == "windows" {
		value, err = globalenv.Get("Path")
	} else {
		value, err = globalenv.Get("PATH")
	}
	if err != nil {
		return err
	}
	path, err := os.Getwd()
	if err != nil {
		return err
	}
	path = filepath.Join(path, "run-scripts")
	if !strings.Contains(value, path) {
		var output []byte
		if runtime.GOOS == "windows" {
			output, err = globalenv.Set("Path", fmt.Sprintf("%s;%s", path, value))
		} else {
			output, err = globalenv.Set("PATH", fmt.Sprintf("$PATH:%s", path))
		}
		if err != nil {
			log.WithField("output", string(output)).Error("setting Path")
			return err
		}
	}
	log.WithField("path", path).Warn("the environment variable is already set")
	return nil
}

func translate2Powershell(ident, cmdName string, level int, cmd cfg.Command) psast.Node {
	subCommand := []psast.Stmt{}
	for name, subcmd := range cmd.Command {
		subNode := translate2Powershell(fmt.Sprintf("%s_%s", ident, name), name, level+1, subcmd)
		if subNode, ok := subNode.([]psast.Stmt); ok {
			subCommand = append(subCommand, subNode...)
		}
	}
	bs := []psast.Stmt{}
	if level > 0 {
		ifStmt := &psast.IfStmt{Body: &psast.BlockStmt{}}
		bs = append(bs, ifStmt)
		ifStmt.Cond = &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.IndexExpr{X: &psast.Ident{Name: "args"}, Key: &psast.BasicExpr{Kind: token.NUMBER, Value: "0"}}}, Op: token.EQ, Y: &psast.BasicExpr{Kind: token.STRING, Value: cmdName}}
		ifStmt.Body.List = append(ifStmt.Body.List, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: "args"}}, Rhs: &psast.RefExpr{X: &psast.IndexExpr{X: &psast.Ident{Name: "args"}, Key: &psast.BinaryExpr{X: &psast.BasicExpr{Kind: token.NUMBER, Value: "1"}, Op: token.DOUBLE_DOT, Y: &psast.RefExpr{X: &psast.SelectorExpr{X: &psast.Ident{Name: "args"}, Sel: &psast.Ident{Name: "Length"}}}}}}})

		ifStmt.Body.List = append(ifStmt.Body.List, psBlockStmtBuild(subCommand, ident, cmd)...)
	} else {
		bs = psBlockStmtBuild(subCommand, ident, cmd)
	}

	return bs
}

func psBlockStmtBuild(subCommand []psast.Stmt, ident string, cmd cfg.Command) (bs []psast.Stmt) {
	for i, sc := range subCommand {
		if i == 0 {
			bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: fmt.Sprintf("temp_args_%s", ident)}}, Rhs: &psast.RefExpr{X: &psast.Ident{Name: "args"}}})
			bs = append(bs, sc)
		} else {
			bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: "args"}}, Rhs: &psast.RefExpr{X: &psast.Ident{Name: fmt.Sprintf("temp_args_%s", ident)}}})
			bs = append(bs, sc)
		}
	}

	typeDict := map[string]token.Token{}
	for _, flag := range cmd.Flags {
		flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
		switch flag.Type {
		case "string":
			typeDict[flagIdent] = token.STRING
			bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}}, Rhs: psast.Null})
		case "bool":
			typeDict[flagIdent] = token.BOOL
			bs = append(bs, &psast.AssignStmt{Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}}, Rhs: psast.False})
		}
	}

	if len(cmd.Flags) > 0 {
		forStmt := &psast.ForStmt{
			Init: &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.ASSIGN, Y: &psast.BasicExpr{Kind: token.NUMBER, Value: "0"}},
			Cond: &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.LT, Y: &psast.RefExpr{X: &psast.SelectorExpr{X: &psast.Ident{Name: "args"}, Sel: &psast.Ident{Name: "Length"}}}},
			Post: &psast.IncDecExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.Inc},
			Body: &psast.BlockStmt{}}
		bs = append(bs, forStmt)

		switchStmt := &psast.SwitchStmt{
			Regex: true,
			Cond:  &psast.RefExpr{X: &psast.IndexExpr{X: &psast.Ident{Name: "args"}, Key: &psast.RefExpr{X: &psast.Ident{Name: "i"}}}},
		}
		forStmt.Body.List = append(forStmt.Body.List, switchStmt)

		for _, flag := range cmd.Flags {
			flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
			alias := []string{}
			if len(flag.Alias) == 0 {
				alias = append(alias, flag.Name)
			} else {
				alias = append(alias, flag.Alias...)
			}
			for i, a := range alias {
				alias[i] = regexp.QuoteMeta(a)
			}
			rule := strings.Join(alias, "|")
			caseStmt := &psast.CaseStmt{
				Cond: &psast.BasicExpr{Kind: token.STRING, Value: rule},
				Body: &psast.BlockStmt{},
			}
			switchStmt.Cases = append(switchStmt.Cases, caseStmt)
			switch flag.Type {
			case "string":
				caseStmt.Body.List = append(caseStmt.Body.List, &psast.AssignStmt{
					Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}},
					Rhs: &psast.IndexExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "args"}}, Key: &psast.BinaryExpr{X: &psast.RefExpr{X: &psast.Ident{Name: "i"}}, Op: token.ADD, Y: &psast.BasicExpr{Kind: token.NUMBER, Value: "1"}}},
				})
				caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
					X: &psast.IncDecExpr{
						X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
						Op: token.Inc,
					},
				})
			case "bool":
				caseStmt.Body.List = append(caseStmt.Body.List, &psast.AssignStmt{
					Lhs: &psast.RefExpr{X: &psast.Ident{Name: flagIdent}},
					Rhs: psast.True,
				})
				// caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
				// 	X: &psast.IncDecExpr{
				// 		X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
				// 		Op: token.Inc,
				// 	},
				// })
			}
		}

		type sortedMatchCase struct {
			weight int
			names  []string
			body   string
		}

		match := []sortedMatchCase{}
		var defaultMatchCase *sortedMatchCase
		for _, matchCase := range cmd.Match {
			if len(matchCase.Platform) > 0 && matchCase.Platform != "powershell" {
				continue
			}
			names := []string{}
			matchCase.Run = indexArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := indexArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					i, _ := strconv.Atoi(matched[0][1])
					i--
					return fmt.Sprintf(`"$($args[%d])"`, i)
				}
				return s
			})
			matchCase.Run = namedArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := namedArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					return fmt.Sprintf("$%s_%s", ident, matched[0][1])
				}
				return s
			})
			matchCase.Run = envArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := envArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					return fmt.Sprintf("$env:%s", matched[0][1])
				}
				return s
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					defaultMatchCase = &sortedMatchCase{
						body: matchCase.Run,
					}
					continue
				}
				names = append(names, fmt.Sprintf("%s_%s", ident, pattern))
			case []any:
				for _, v := range pattern {
					if v, ok := v.(string); ok {
						names = append(names, fmt.Sprintf("%s_%s", ident, v))
					}
				}
			}
			if len(names) != 0 {
				match = append(match, sortedMatchCase{weight: len(names), names: names, body: matchCase.Run})
			}
		}

		if len(match) == 0 {
			return bs
		}

		sort.Slice(match, func(i, j int) bool {
			return match[i].weight > match[j].weight
		})

		matchStmt := &psast.IfStmt{Body: &psast.BlockStmt{}}
		bs = append(bs, matchStmt)
		for i, c := range match {
			cases := []string{}
			for _, name := range c.names {
				switch typeDict[name] {
				case token.STRING:
					cases = append(cases, fmt.Sprintf("$null -ne $%s", name))
				case token.BOOL:
					cases = append(cases, fmt.Sprintf("$%s -ne $false", name))
				}
			}
			matchStmt.Cond = &psast.Ident{Name: strings.Join(cases, " -and ")}
			if len(c.body) > 0 {
				lines := strings.Split(c.body, "\n")
				for i, line := range lines {
					if i == len(lines)-1 && len(line) == 0 {
						continue
					}
					matchStmt.Body.List = append(matchStmt.Body.List, &psast.CallStmt{Func: &psast.Ident{Name: line}})
				}
			}
			matchStmt.Body.List = append(matchStmt.Body.List, &psast.CallStmt{Func: &psast.Ident{Name: "exit"}})
			if i != len(match)-1 {
				ifstmt := &psast.IfStmt{Body: &psast.BlockStmt{}}
				matchStmt.Else = ifstmt
				matchStmt = ifstmt
			}
		}

		if defaultMatchCase != nil {
			matchStmt.Else = &psast.BlockStmt{
				List: []psast.Stmt{
					&psast.ExprStmt{X: &psast.Ident{Name: defaultMatchCase.body}},
				},
			}
		}
	}
	return bs
}

func translate2Bash(ident, cmdName string, level int, cmd cfg.Command) bashast.Node {
	subCommand := []bashast.Stmt{}
	for name, subcmd := range cmd.Command {
		subNode := translate2Bash(fmt.Sprintf("%s_%s", ident, name), name, level+1, subcmd)
		if subNode, ok := subNode.([]bashast.Stmt); ok {
			subCommand = append(subCommand, subNode...)
		}
	}
	bs := []bashast.Stmt{}
	if level > 0 {
		ifStmt := &bashast.IfStmt{Body: &bashast.BlockStmt{}}
		bs = append(bs, ifStmt)
		ifStmt.Cond = &bashast.BinaryExpr{X: &bashast.RefExpr{X: &bashast.IndexExpr{X: &bashast.Ident{Name: "args"}, Key: &bashast.BasicExpr{Kind: bashtoken.NUMBER, Value: "0"}}}, Op: bashtoken.EQ, Y: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: cmdName}}
		ifStmt.Body.List = append(ifStmt.Body.List, &bashast.ExprStmt{X: &bashast.Ident{Name: `args=("${args[@]:1}")`}})

		ifStmt.Body.List = append(ifStmt.Body.List, bashBlockStmtBuild(subCommand, ident, cmd)...)
	} else {
		bs = bashBlockStmtBuild(subCommand, ident, cmd)
	}

	return bs
}

func bashBlockStmtBuild(subCommand []bashast.Stmt, ident string, cmd cfg.Command) (bs []bashast.Stmt) {
	for i, sc := range subCommand {
		if i == 0 {
			if i != len(subCommand)-1 {
				bs = append(bs, &bashast.AssignStmt{Lhs: &bashast.Ident{Name: fmt.Sprintf("temp_args_%s", ident)}, Rhs: &bashast.Ident{Name: `("${args[@]}")`}})
			}
			bs = append(bs, sc)
		} else {
			bs = append(bs, &bashast.AssignStmt{Lhs: &bashast.Ident{Name: "args"}, Rhs: &bashast.Ident{Name: fmt.Sprintf(`("${temp_args_%s[@]}")`, ident)}})
			bs = append(bs, sc)
		}
	}

	typeDict := map[string]token.Token{}
	for _, flag := range cmd.Flags {
		flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
		switch flag.Type {
		case "string":
			typeDict[flagIdent] = token.STRING
			bs = append(bs, &bashast.AssignStmt{Lhs: &bashast.Ident{Name: flagIdent}, Rhs: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: ""}})
		case "bool":
			typeDict[flagIdent] = token.BOOL
			bs = append(bs, &bashast.AssignStmt{Lhs: &bashast.Ident{Name: flagIdent}, Rhs: &bashast.BasicExpr{Kind: bashtoken.BOOL, Value: "false"}})
		}
	}

	if len(cmd.Flags) > 0 {
		forStmt := &bashast.ForStmt{
			Init: &bashast.BinaryExpr{X: &bashast.Ident{Name: "i"}, Op: bashtoken.ASSIGN, Y: &bashast.BasicExpr{Kind: bashtoken.NUMBER, Value: "0"}},
			Cond: &bashast.BinaryExpr{X: &bashast.Ident{Name: "i"}, Op: bashtoken.LT, Y: &bashast.Ident{Name: "${#args[@]}"}},
			Post: &bashast.IncDecExpr{X: &bashast.Ident{Name: "i"}, Op: bashtoken.Inc},
			Body: &bashast.BlockStmt{}}
		bs = append(bs, forStmt)
		switchStmt := &bashast.SwitchStmt{
			Cond: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: "${args[i]}"},
		}
		forStmt.Body.List = append(forStmt.Body.List, switchStmt)

		for _, flag := range cmd.Flags {
			flagIdent := fmt.Sprintf("%s_%s", ident, flag.Name)
			alias := []string{}
			if len(flag.Alias) == 0 {
				alias = append(alias, flag.Name)
			} else {
				alias = append(alias, flag.Alias...)
			}
			for i, a := range alias {
				alias[i] = regexp.QuoteMeta(a)
			}
			rule := strings.Join(alias, "|")
			caseStmt := &bashast.CaseStmt{
				Cond: &bashast.Ident{Name: rule},
				Body: &bashast.BlockStmt{},
			}
			switchStmt.Cases = append(switchStmt.Cases, caseStmt)
			switch flag.Type {
			case "string":
				caseStmt.Body.List = append(caseStmt.Body.List, &bashast.AssignStmt{
					Lhs: &bashast.Ident{Name: flagIdent},
					Rhs: &bashast.BasicExpr{Kind: bashtoken.STRING, Value: "${args[i+1]}"},
				})
				caseStmt.Body.List = append(caseStmt.Body.List, &bashast.ExprStmt{X: &bashast.Ident{Name: "((i++))"}})
			case "bool":
				caseStmt.Body.List = append(caseStmt.Body.List, &bashast.AssignStmt{
					Lhs: &bashast.Ident{Name: flagIdent},
					Rhs: &bashast.Ident{Name: "true"},
				})
				// caseStmt.Body.List = append(caseStmt.Body.List, &psast.ExprStmt{
				// 	X: &psast.IncDecExpr{
				// 		X:  &psast.RefExpr{X: &psast.Ident{Name: "i"}},
				// 		Op: token.Inc,
				// 	},
				// })
			}
		}

		type sortedMatchCase struct {
			weight int
			names  []string
			body   string
		}

		match := []sortedMatchCase{}
		var defaultMatchCase *sortedMatchCase
		for _, matchCase := range cmd.Match {
			if len(matchCase.Platform) > 0 && matchCase.Platform != "bash" {
				continue
			}
			names := []string{}
			matchCase.Run = indexArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := indexArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					i, _ := strconv.Atoi(matched[0][1])
					i--
					return fmt.Sprintf(`"$($args[%d])"`, i)
				}
				return s
			})
			matchCase.Run = namedArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := namedArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					// shellcheck: Double quote to prevent globbing and word splitting.
					return fmt.Sprintf(`"$%s_%s"`, ident, matched[0][1])
				}
				return s
			})
			matchCase.Run = envArguments.ReplaceAllStringFunc(matchCase.Run, func(s string) string {
				matched := envArguments.FindAllStringSubmatch(s, -1)
				if len(matched) > 0 && len(matched[0]) > 1 {
					return fmt.Sprintf("$%s", matched[0][1])
				}
				return s
			})
			switch pattern := matchCase.Pattern.(type) {
			case string:
				if pattern == "_" || len(pattern) == 0 {
					defaultMatchCase = &sortedMatchCase{
						body: matchCase.Run,
					}
					continue
				}
				names = append(names, fmt.Sprintf("%s_%s", ident, pattern))
			case []any:
				for _, v := range pattern {
					if v, ok := v.(string); ok {
						names = append(names, fmt.Sprintf("%s_%s", ident, v))
					}
				}
			}
			if len(names) != 0 {
				match = append(match, sortedMatchCase{weight: len(names), names: names, body: matchCase.Run})
			}
		}

		if len(match) == 0 {
			return bs
		}

		sort.Slice(match, func(i, j int) bool {
			return match[i].weight > match[j].weight
		})

		matchStmt := &bashast.IfStmt{Body: &bashast.BlockStmt{}}
		bs = append(bs, matchStmt)
		for i, c := range match {
			cases := []string{}
			for _, name := range c.names {
				switch typeDict[name] {
				case token.STRING:
					cases = append(cases, fmt.Sprintf(`-n "$%s"`, name))
				case token.BOOL:
					cases = append(cases, fmt.Sprintf("$%s == true", name))
				}
			}
			matchStmt.Cond = &bashast.Ident{Name: strings.Join(cases, " && ")}
			if len(c.body) > 0 {
				lines := strings.Split(c.body, "\n")
				for i, line := range lines {
					if i == len(lines)-1 && len(line) == 0 {
						continue
					}
					matchStmt.Body.List = append(matchStmt.Body.List, &bashast.CallStmt{Func: &bashast.Ident{Name: line}})
				}
			}
			matchStmt.Body.List = append(matchStmt.Body.List, &bashast.CallStmt{Func: &bashast.Ident{Name: "exit"}})
			if i != len(match)-1 {
				ifstmt := &bashast.IfStmt{Body: &bashast.BlockStmt{}}
				matchStmt.Else = ifstmt
				matchStmt = ifstmt
			}
		}

		if defaultMatchCase != nil {
			matchStmt.Else = &bashast.BlockStmt{
				List: []bashast.Stmt{
					&bashast.ExprStmt{X: &bashast.Ident{Name: defaultMatchCase.body}},
				},
			}
		}
	}
	return
}
